# Друга вежба

**Више класа у једном програму**

[:fontawesome-regular-file-pdf: Нерешени задаци](../../assets/OOP_2020_LV2.pdf)

/// warning | У изради!
Страница је још увек у изради и нису доступна решења свих задатака.
///

## Задатак 0.

Направити класу _Complex_ за моделовање комплексних бројева. Од приватних чланова треба да има по један `#!cpp double` атрибут за реални и имагинарни део, а од јавних операторе за унос и штампање, методе за сабирање и одузимање које враћају нови објекат, као и све неопходне конструкторе и методе за приступ приватним члановима.

Класу _Skup_, направљеној у првој вежби, модификовати тако да уместо низа елемената типа `#!cpp int` садржи низ елемената типа `Complex` и додати:

-   методу која одређује разлику два скупа (резултат је нови објекат типа `Skup`),
-   методу која одређује унију два скупа (резултат је нови објекат типа `Skup`),
-   методу која одређује пресек два скупа (резултат је нови објекат типа `Skup`),
-   операторску методу `=` која пресликава један скуп у други.

Методу за учитавање елемената скупа са стандардног улаза заменити пријатељском операторском методом `>>` за учитавање елемената из текстуалног тока података, а методу за приказ елемената на стандардни излаз пријатељском операторском методом `<<` за упис елемената скупа у текстуални ток података.

У функцији _main_ инстанцирати неколико објеката класе _Skup_ у динамичкој зони меморије, учитати њихове елементе и на стандардни излаз приказати њихову унију, пресек и разлику.

### Програмски ко̑д

/// tab | :jb-h: Complex.h

```cpp
#ifndef COMPLEX_H
#define COMPLEX_H
#include <ostream>

class Complex {
private:
    double real;
    double imag;

public:
    Complex();

    Complex(double r, double i);

    double Real() const {
        return real;
    }

    double Imag() const {
        return imag;
    }

    friend std::istream &operator>>(std::istream &in, Complex &c);

    friend std::ostream &operator<<(std::ostream &out, const Complex &c);

    Complex operator+(const Complex &c) const;

    Complex operator-(const Complex &c) const;

    bool operator==(const Complex &c) const;

    bool operator>(const Complex &c) const;

    bool operator<(const Complex &c) const;
};


#endif
```

///

/// tab | :jb-cpp: Complex.cpp

```cpp
#include "Complex.h"
#include <istream>
#include <ostream>
#include <cmath>

Complex::Complex() {
    real = 0;
    imag = 0;
}

Complex::Complex(double r, double i) {
    real = r;
    imag = i;
}

std::istream &operator>>(std::istream &in, Complex &c) {
    in >> c.real >> c.imag;
    return in;
}

std::ostream &operator<<(std::ostream &out, const Complex &c) {
    if (c.imag < 0) {
        out << c.real << " - " << -c.imag << "i";
    } else {
        out << c.real << " + " << c.imag << "i";
    }

    return out;
}

Complex Complex::operator+(const Complex &c) const {
    return {real + c.real, imag + c.imag};
}

Complex Complex::operator-(const Complex &c) const {
    return {real - c.real, imag - c.imag};
}

bool Complex::operator==(const Complex &c) const {
    return real == c.real && imag == c.imag;
}

bool Complex::operator>(const Complex &c) const {
    return sqrt(pow(real, 2) + pow(imag, 2)) > sqrt(pow(c.real, 2) + pow(c.imag, 2));
}

bool Complex::operator<(const Complex &c) const {
    return c > *this;
}
```

///

/// tab | :jb-h: Skup.h

```cpp
#ifndef SKUP_H
#define SKUP_H


#include "Complex.h"

class Skup {
private:
    int brElemenata;
    Complex *elementi;

public:
    Skup();

    Skup(int brElemenata);

    ~Skup();

    int BrElemenata() const {
        return brElemenata;
    }

    int UkloniDuplikate();

    bool Pripada(Complex element) const;

    void Uredi();

    Skup Razlika(const Skup &s) const;

    Skup Unija(const Skup &s) const;

    Skup Presek(const Skup &s) const;

    Skup &operator=(const Skup &s);

    friend std::istream &operator>>(std::istream &in, Skup &s);

    friend std::ostream &operator<<(std::ostream &out, const Skup &s);
};


#endif
```

///

/// tab | :jb-cpp: Skup.cpp

```cpp
#include <iostream>
#include "Skup.h"

Skup::Skup() {
    brElemenata = 0;
    elementi = nullptr;
}

Skup::Skup(int brElemenata) {
    this->brElemenata = brElemenata;
    this->elementi = new Complex[brElemenata];
}

Skup::~Skup() {
    delete[] elementi;
}

int Skup::UkloniDuplikate() {
    int stariBr = brElemenata;
    for (int i = 0; i < brElemenata; i++) {
        for (int j = brElemenata - 1; j > i; j--) {
            if (elementi[i] == elementi[j]) {
                for (int k = j; k < brElemenata - 1; k++) {
                    elementi[k] = elementi[k + 1];
                }
                brElemenata--;
            }
        }
    }

    return stariBr - brElemenata;
}

bool Skup::Pripada(const Complex element) const {
    for (int i = 0; i < brElemenata; i++) {
        if (element == elementi[i]) {
            return true;
        }
    }

    return false;
}

void Skup::Uredi() {
    for (int i = 0; i < brElemenata - 1; i++) {
        for (int j = i + 1; j < brElemenata; j++) {
            if (elementi[j] > elementi[i]) {
                auto pom = elementi[j];
                elementi[j] = elementi[i];
                elementi[i] = pom;
            }
        }
    }
}

Skup Skup::Razlika(const Skup &s) const {
    auto razlika = Skup(brElemenata);

    razlika.brElemenata = 0;
    for (int i = 0; i < brElemenata; i++) {
        if (!s.Pripada(elementi[i])) {
            razlika.elementi[razlika.brElemenata++] = elementi[i];
        }
    }

    return razlika;
}

Skup Skup::Unija(const Skup &s) const {
    auto unija = Skup(brElemenata + s.brElemenata);

    int j = 0;
    for (int i = 0; i < brElemenata; i++) {
        unija.elementi[j++] = elementi[i];
    }

    for (int i = 0; i < s.brElemenata; i++) {
        unija.elementi[j++] = s.elementi[i];
    }

    return unija;
}

Skup Skup::Presek(const Skup &s) const {
    auto presek = Skup(std::min(brElemenata, s.brElemenata));
    presek.brElemenata = 0;

    for (int i = 0; i < brElemenata; i++) {
        if (s.Pripada(elementi[i])) {
            presek.elementi[presek.brElemenata++] = elementi[i];
        }
    }

    return presek;
}

Skup &Skup::operator=(const Skup &s) {
    if (this == &s) {
        return *this;
    }

    brElemenata = s.brElemenata;
    elementi = new Complex[brElemenata];

    for (int i = 0; i < brElemenata; i++) {
        elementi[i] = s.elementi[i];
    }

    return *this;
}

std::istream &operator>>(std::istream &in, Skup &s) {
    for (int i = 0; i < s.brElemenata; i++) {
        in >> s.elementi[i];
    }

    return in;
}

std::ostream &operator<<(std::ostream &out, const Skup &s) {
    out << "{";
    for (int i = 0; i < s.brElemenata; i++) {
        out << s.elementi[i];
        if (i != s.brElemenata - 1) {
            out << ", ";
        }
    }
    out << "}";

    return out;
}
```

///

/// tab | :jb-cpp: main.cpp

```cpp
#include <fstream>
#include <iostream>

#include "Skup.h"

int main() {
    auto skup1 = new Skup(5);
    auto skup2 = new Skup(7);
    auto skup3 = new Skup(5);
    auto skup4 = new Skup(6);

    std::ifstream in1("./test-data/skup1.txt");
    in1 >> *skup1;
    in1.close();

    std::ifstream in2("./test-data/skup2.txt");
    in2 >> *skup2;
    in2.close();

    std::ifstream in3("./test-data/skup3.txt");
    in3 >> *skup3;
    in3.close();

    std::ifstream in4("./test-data/skup4.txt");
    in4 >> *skup4;
    in4.close();

    std::cout << *skup1 << std::endl;
    std::cout << *skup2 << std::endl;
    std::cout << *skup3 << std::endl;
    std::cout << *skup4 << std::endl;

    std::cout << "Unija 1 i 2: " << skup1->Unija(*skup2) << std::endl;
    std::cout << "Presek 3 i 4: " << skup3->Presek(*skup4) << std::endl;
    std::cout << "Razlika 2 i 1: " << skup2->Razlika(*skup1) << std::endl;

    delete skup1;
    delete skup2;
    delete skup3;
    delete skup4;

    return 0;
}
```

///

## Задатак 1.

Направити класу _Ispit_ која од приватних чланова треба да има једну променљиву у којој се памти име испита (тип `#!cpp char*`), једну за чување датума полагања испита у формату `yyyy-MM-dd` (нпр. `2017-11-06`) и једну у којој се памти оцена (тип `int`). Од јавних чланова класа треба да садржи методе које треба да пореде два објекта класе _Ispit_ по оцени или датуму полагања, методе за унос и штампање, као и све неопходне конструкторе и методе за приступ приватне чланове.

У класи _Student_, направљеној у првој вежби, заменити вектор оцена вектором објеката класе _Ispit_ и додати:

-   конструктор без аргумената који број испита поставља на 50,
-   методу која пореди два студената према просечној оцени,
-   операторску методу `=` која један објекат класе _Student_ додељује другом.

Методу за учитавање података о студенту са стандардног улаза заменити пријатељском операторском методом `>>` за учитавање података о студенту из текстуалног тока података, а методу за приказ података о студенту на стандардни излаз пријатељском операторском методом `<<` за упис података о студенту на текстуални ток података.

У функцији _main_ инстанцирати вектор објеката класе _Student_ у динамичкој зони меморије, учитати њихове податке, уредити низ према просечној оцени и уређени низ приказати на стандардни излаз.

Након тога, уредити низ студената по најкраћем времену између првог и задњег положеног испита и уређени низ приказати на стандардни излаз.

На крају сортирати студенте по броју положених испита и приказати сортирану листу на стандардни излаз.

## Задатак 2.

У класи _Poligon_ направљеној у првој вежби, додати:

-   методу која пресликава полигон симетрично у односу на _x_ осу,
-   методу која пресликава полигон симетрично у односу на _y_ осу.

Методу за учитавање координата темена са стандардног улаза заменити пријатељском операторском методом `>>` за учитавање координата из тексуталног тока података, а методу за приказ координата темена на стандардни излаз, пријатељском операторском методом `<<` за упис координата у текстуални ток података.

Додати у пројекат класу _Slika_ која од приватних чланова има максималан број полигона на слици и динамички низ типа _Poligon_, а од јавних чланова методе за додавање полигона у низ као и оператор за штампање.

У финкцији _main_ инстанцирати објекат класе _Poligon_ у динамичкој зони мемотије са _n_ темена, учитати координате темена и пресликати га симетрично у односу на _x_, а онда и у односу на _y_ осу и након сваког пресликавања приказивати координате темена на стандардни излаз. Исто то урадити и са једним објектом класе _Poligon_ са _m_ темена. Инстанцирати један објекат класе _Slika_ са максимално _k_ елемената и додати му инстанцирана два полигона и додатно инстанритати још `k - 2` тако што ћете њихове податке унети са стандардног улаза.

## Задатак 3.

У класу која описује црно-беле слике (надаље ће бити звана _Image_), која је направљена у првој вежби, додати:

-   методу која преклапа садржаје двеју слика (у резултујућој слици пиксел на позицији `i, j` добија вредност 1 ако је бар у једној од слика које се преклапају на тој позицији била вредност 1),
-   методу која ротира слику за 90 степени у смеру казаљке на сату,
-   операторску методу `=` за доделу једног објеката класе другом.

Методу за учитавање садржаја слике са стандардног улаза заменити пријатељском операторском методом `>>` за учитавање садржаја слике из текстуалног тока података, а методу за приказ садржаја слике на стандардни излаз пријатељском операторском методом `<<` за упис садржаја слике у текстуални ток података.

Додати у пројекат класу _Kolekcija_ која од приватних чланова има максимални број слика у колекцији и динамички низ типа _Image_, а од јавних чланова методе за додавање слика у колекцију и за штампање.

У функцији _main_ инстанцирати два објеката класе _Image_ у динамичкој зони меморије, учитати њихове садржаје, инвертовати их и извршити њихово преклапање. Резултујућу слику доделити трћем објекту класе _Image_ и његов садржај приказати на стандардни излаз. Инстанцирати један објекат класе _Kolekcija_, додати му направљене слике и одштампати га на стандардни излаз.

## Задатак 4.

Направити класу _Complex_ за моделовање комплексних бројева. Од приватних чланова трева да има по један `#!cpp double` атрибут за реални и имагинарни део комплексног броја, а од јеваних методе за унос, штампање, сабирање и одузимање, рачунање модула, поређење по модулу, као и све неопходне конструкторе и методе за приступ приватним члановима.

Класу _Buffer_, направљној у првој вежби, преправити да ради са објектима типа _Complex_, а не са целобројним подацима, и у њој додати:

-   методу која надовезује садржај једног на садржај другог бафера,
-   методу која из бафера избацује елемент са задате локације,
-   методу која из бафера избацује све елементе мање од прослеђене вредности,
-   методу која рачуна просечну вредност елемената у баферу,
-   оператроску методу `=` за доделу једног објекта класе _Buffer_ другом.

Методу за приказ садржаја бафера на стандарни излаз заменити пријатељском методом `<<` за упис садржаја бафера у текстуални ток података.

У функцији _main_ инстанцирати неколико објеката класе _Buffer_, у њих уписати по неколико елемената, надовезати их и резултујући објекат доделити новом објекту класе _Buffer_. Из тог објекта избацити неки од унетих елемената и приказати га на стандардни излаз.

## Задатак 5.

Направити класу _Tacka_ за моделовање тродимензионалних тачака. Од приватних чланова класа треба да садржи по један `#!cpp double` атрибут за сваку од три димензије, а од јавних методе за унос, штампање, сабирање, одузимање и множење скаларом и све неопходне конструкторе и методе за приступ приватним члановима.

У класи _Vektor_ направљеној у првој вежби, заменити низ целих бројева низом елемената типа _Tacka_ и додати:

-   методу која сабира елементе два низа исте дужине,
-   методу која избацује све дупликате из низа и уређује преостале вредности у растући редослед,
-   методу која ротира садржај вектора за једно место удесно,
-   методу која ротира садржај вектора за једно место улево,
-   операторску методу `=` за доделу једног објекта класе _Vektor_ другом,
-   операторску методу `>>` за учитавање садржаја низа из задатог текстуалног тока,
-   операторску методу `<<` за учитавање садржаја низа из задатог текстуалног тока,

У функцији _main_ инстанцирати неколико објеката класе _Vektor_ и на стандардни излаз приказати њихов збир, производ, резултат сабирања са константом _n_ и резултат множења константом _m_ и другог низа. Резултат сваке операције најпре доделити новом објекту и садржај тог објекта приказати.

## Задатак 6.

У класи _Minesweeper_, направљеној у првој вежби, додати:

-   методу која све мине у минском пољу помера за једно место удесно (мине из последње колоне преноси у прву),
-   методу која све мине у минском пољу помера за једно место надоле (мине из последње врсте преноси у прву),
-   методу која све мине у минском пољу помера за једно место улево (мине из прве колоне преноси у последњу),
-   методу која све мине у минском пољу помера за једно место нагоре (мине из прве врсте преноси у последњу),
-   методу која свако _n_-то празно поље мења мином,
-   операторску методу `>>` за учитавање садржаја минског поља из задатог текстуалног тока,
-   операторску методу `<<` за упис садржаја минсог поља у текстуални ток података.

У финкцији _main_ инстанцирати објекат класе _Minesweeper_ и транслирати мине у сва четири смера. Након сваког транслирања нови садржај минсог поља приказати на стандардни излаз.

## Задатак 7.

Направити класу _Tacka_ за моделовање тродимензионалних тачака. Од приватних чланова класа треба да садржи по један `#!cpp double` атрибут за сваку од три димензија, а од јавних методе за унос, штампање, сабирање, одузимање и све неопходне конструкторе и методе за приступ приватним члановима.

У класи _Matrica_, направљеној у првој вежби, додати:

-   методу која повећава вредност сваке компоненте сваке тачке за 1,
-   методу која сумира све елементе из врсте чији се индекс прослеђује као параметар методе,
-   методу која нормализује све координате у оквиру прослеђених граница,
-   операторску методу `=` за доделу једног објекта класе _Matrica_ другом,
-   методу која враћа тачку која се налази на прослеђеним координатама,
-   пријатељску операторску методу `>>` за учитавање садржаја матрице из задатог текстуалног тока,
-   пријатељску операторску методу `<<` за упис садржаја матрице у текстуални ток података.

У функцији _main_ инстанцирати објекат класе _Matrica_ димензија *m*×*n*, учитати вредности ћелија матрице, сумирати вредности колоне _k_ и _l_, као и редова _p_ и _q_, демонстрирати употребу свих имплементираних метода, а потом одштампати матрицу.

## Задатак 8.

У класи _String_, направљеној у првој вежби, додати:

1. методу која врши надовезивање две ниске,
2. методу која прво слова у нисци конвертује у велико,
3. методу која сва слова у нисци конвертује у велика,
4. методу _PadRight_ која са десне стране проширује ниску прослеђеним карактером док не достигне захтевану дужину,
5. операторску методу `=` која један објекат класе _String_ додељује другом.

Методу за учитавање ниске са стандардно улаза заменити пријатељском операторском методом `>>` за учитавање садржаја из текстуалног тока података, а методу за приказ ниске на стандардни излаз заменити пријатељскомоператорском методом `<<` за упис ниске у текстуални ток података.

Додати у пројкат класу _Paragraf_ која од приватних чланова има максималан број ниски и динамички низ типа _String_, а од јавних чланова методе за додавање ниске у параграф, као и методе за приказ.

У функцији _main_ инстанцирати неколико објеката класе _String_, учитати њихове вредности и сачувати копију свак од унетих ниски. Испробати методе 2, 3, 4. над унетим нискама и тако промењене ниске конкатенирати и одштампати резултујућу ниску. Инстанцирати један објекат класе _Paragraf_, додати му све копије почетних ниски и приказати параграф на стандардни излаз.

## Задатак 9.

У класи _Picture_, која је направљена у првој вежби, додати:

-   методу која преклапа садржај двеју слика (у резултујућој слици пиксел на позицији _i_,_j_ добија вредност средње вредности пиксела из полазних слика),
-   методу која броји различите боје на слици, односно враћа број различитих вредности којима су описани пиксели,
-   операторску методу `=` за доделу једног објекта класе _Picture_ другом,

Методу за учитавање садржаја слике са стандардног улаза заменити пријатељском операторском методом `>>` за учитавање садржаја слике из текстуалног тока података, а методу за приказ садржаја слике на стандардни излаз пријатељком операторском методом `<<` за упис садржаја слике у текстуални ток података.

Додати у пројекат класу _Kolekcija_ која од приватних члановима има максималан број слика у колекцији и динамички низ тима _Image_, а од јавних чланова методе за додавање слиак у коликцију као и оператор за приказивање елемената колекције.

У функцији _main_ инстанцирати неколико објеката класе _Picture_ реда *m*×*n*, учитати њихове садржаје и испробати све имплементиране методе. Инстанцирати један објекат типа _Kolekcija_, додати му све инстанциране слике и приказати тај објекат на стандардни излаз.
