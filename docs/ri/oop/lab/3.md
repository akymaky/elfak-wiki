# Трећа вежба

**Наслеђивање**

[:fontawesome-regular-file-pdf: Нерешени задаци](../../../assets/OOP_2020_LV3.pdf)

## Задатак 0.

На програмском језику _C++_ имплементирати класу _Funkcija_ ($f(x) = kx + n$). Класа садржи три заштићена атрибута: коефицијенте _k_ и _n_ (представљени реалним бројевима) и назив функције (знаковни низ запамћен у динамичкој зони меморије). Такође, поседује и следеће јавне чланице:

-   подразумевани конструктор који иницијализује коефицијенте _k_ на 1, _n_ на 0, а назив на „_Linearna funkcija_”,
-   конструктор којим се постављају вредности _k_ и _n_,
-   виртуалну методу која одређује вредност функције за _x_,
-   виртуалну методу _prikaziFunkciju_ за штампање атрибута класе,
-   виртуални деструктор који брише податке из динамичке зоне меморије уколико постоје.

Из класе _Funkcija_ извести класе _KvadratnaFunkcija_, облика $f(x) = (x + n)^k$, и _EksponencijalnaFunkcija_, облика $f(x) = k^{x + n}$ где је $k = e$. Обе класе треба да имплементују следеће јавне чланице:

-   подразумевани конструктор,
-   конструктор којим се постављају вредности свих атрибута,
-   предефинисану методу која одређује вредност функције за _x_,
-   предефинисану методу _prikaziFunkciju_ која штампа податке о класи,
-   деструктор који брише податке из динамичке зоне меморије уколико постоје.

У функцији _main_ направити низ од 2019 показивача на објекте класе _Funkcija_. Поставити низ тако да садржи објекте све три класе по 673 пута. Приказати податке из низа на стандардни излаз. За произвољно унету вредност _x_ приказати податке о функцији која има минималну вредност.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <random>

#include "EksponencijalnaFunkcija.h"
#include "Funkcija.h"
#include "KvadratnaFunkcija.h"

int main() {
    auto funkcije = new Funkcija*[2019];

    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_real_distribution<double> dist(-100, 100);

    int i = 0;
    for (int j = 0; j < 673; j++) {
        funkcije[i++] = new Funkcija(dist(mt), dist(mt));
        funkcije[i++] = new KvadratnaFunkcija(dist(mt), dist(mt));
        funkcije[i++] = new EksponencijalnaFunkcija(dist(mt), dist(mt));
    }

    i = 0;
    for (int j = 1; j < 2019; j++) {
        if (funkcije[j]->Calculate(12) < funkcije[i]->Calculate(12)) {
            i = j;
        }
    }

    funkcije[i]->PrikaziFunkciju();

    delete[] funkcije;

    return 0;
}
```

///

/// tab | :jb-h: Funkcija.h

```cpp
#ifndef FUNKCIJA_H
#define FUNKCIJA_H


class Funkcija {
protected:
    double k, n;
    char* naziv;

public:
    Funkcija();

    Funkcija(double k, double n);

    virtual double Calculate(double x);

    virtual ~Funkcija();

    virtual void PrikaziFunkciju();
};


#endif
```

///

/// tab | :jb-cpp: Funkcija.cpp

```cpp
#include "Funkcija.h"

#include <iostream>

Funkcija::Funkcija() {
    k = 1;
    n = 0;
    naziv = new char[]{"Linearna funkcija"};
}

Funkcija::Funkcija(double k, double n) {
    this->k = k;
    this->n = n;
    naziv = new char[]{"Linearna funkcija"};
}

double Funkcija::Calculate(double x) {
    return k * x + n;
}

Funkcija::~Funkcija() {
    delete[] naziv;
}

void Funkcija::PrikaziFunkciju() {
    std::cout << naziv << ": " << k << "x + " << n << std::endl;
}
```

///

/// tab | :jb-h: KvadratnaFunkcija.h

```cpp
#ifndef KVADRATNAFUNKCIJA_H
#define KVADRATNAFUNKCIJA_H
#include "Funkcija.h"


class KvadratnaFunkcija : public Funkcija {
public:
    KvadratnaFunkcija();

    KvadratnaFunkcija(double k, double n);

    double Calculate(double x) override;

    void PrikaziFunkciju() override;

    ~KvadratnaFunkcija() override;
};


#endif
```

///

/// tab | :jb-cpp: KvadratnaFunkcija.cpp

```cpp
#include "KvadratnaFunkcija.h"

#include <cmath>
#include <iostream>

KvadratnaFunkcija::KvadratnaFunkcija() {
    naziv = new char[]{"Kvadratna funkcija"};
}

KvadratnaFunkcija::KvadratnaFunkcija(double k, double n) : Funkcija(k, n) {
    naziv = new char[]{"Kvadratna funkcija"};
}

double KvadratnaFunkcija::Calculate(double x) {
    return std::pow(x + n, k);
}

void KvadratnaFunkcija::PrikaziFunkciju() {
    std::cout << naziv << ": (x + " << n << ")^" << k << std::endl;
}

KvadratnaFunkcija::~KvadratnaFunkcija() {
    delete[] naziv;
}
```

///

/// tab | :jb-h: EksponencijalnaFunkcija.h

```cpp
#ifndef EKSPONENCIJALNAFUNKCIJA_H
#define EKSPONENCIJALNAFUNKCIJA_H
#include "Funkcija.h"


class EksponencijalnaFunkcija : public Funkcija {
public:
    EksponencijalnaFunkcija();

    EksponencijalnaFunkcija(double k, double n);

    double Calculate(double x) override;

    void PrikaziFunkciju() override;

    ~EksponencijalnaFunkcija() override;
};


#endif
```

///

/// tab | :jb-cpp: EksponencijalnaFunkcija.cpp

```cpp
#include "EksponencijalnaFunkcija.h"

#include <cmath>
#include <iostream>

EksponencijalnaFunkcija::EksponencijalnaFunkcija() {
    naziv = new char[]{"Eksponencijalna funkcija"};
}

EksponencijalnaFunkcija::EksponencijalnaFunkcija(double k, double n) : Funkcija(k, n) {
    naziv = new char[]{"Eksponencijalna funkcija"};
}

double EksponencijalnaFunkcija::Calculate(double x) {
    return std::pow(k, x + n);
}

void EksponencijalnaFunkcija::PrikaziFunkciju() {
    std::cout << naziv << ": " << k << "^(x + " << n << ")" << std::endl;
}

EksponencijalnaFunkcija::~EksponencijalnaFunkcija() {
    delete[] naziv;
}
```

///

## Задатак 1.

На програмском језику _C++_ имплементирати класу _Figura_. Класа садржи два заштићена атрибута: број страница и низ страница (низ реалних бројева запамћених у динамичкој зони меморије). Такође, поседује и следеће јавне чланице:

-   подразумевани конструктор који иницијализује број страница на 0,
-   конструктор којим се постављају странице као и њихов број,
-   виртуалну методу која рачуна површину,
-   виртуалну методу _Prikazi_ за штампање атрибута класе,
-   виртуални деструктор који брише податке из динамичке зоне меморије уколико постоје.

Из класе _Figura_ извести класе _Kvadrat_ и _Pravougaonik_. Обе класе треба да имплементују следеће чланице:

-   подразумевани конструктор,
-   предефинисану методу _Prikazi_ која штампа податке о класи,
-   деструктор који брише податке из динамичке зоне меморије уколико постоје.

За класу _Kvadrat_ додати конструктор којим се све странице постављају на вредност _a_. За класу _Pravougaonik_ додати конструктор којим се све странице постављају одговарајућим вредностима _a_ и _b_.

У функцији _main_ инстанцирати низ од 2018 показивача на објекте класе _Figura_. Поставити низ тако да садржи по најмање 1009 објеката класе _Kvadrat_ и _Pravougaonik_. Приказати податке из низа на стандардни излаз. Сортирати низ по површини, а затим сачувати низ у текстуалну датотеку.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <fstream>
#include <random>

#include "Figura.h"
#include "Kvadrat.h"
#include "Pravougaonik.h"

int main() {
    auto figure = new Figura*[2018];

    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_real_distribution<double> dist(-100, 100);

    int i = 0;
    for (int j = 0; j < 1009; j++) {
        figure[i++] = new Kvadrat(dist(mt));
        figure[i++] = new Pravougaonik(dist(mt), dist(mt));
    }

    for (int j = 0; j < 2018; j++) {
        figure[j]->Prikazi();
    }

    for (int j = 0; j < 2017; j++) {
        for (int k = j + 1; k < 2018; k++) {
            if (figure[j]->Povrsina() > figure[k]->Povrsina()) {
                auto tmp = figure[j];
                figure[j] = figure[k];
                figure[k] = tmp;
            }
        }
    }

    std::ofstream out("figure.txt");
    for (int j = 0; j < 2018; j++) {
        out << figure[j]->Povrsina() << std::endl;
    }

    out.close();

    delete[] figure;

    return 0;
}
```

///

/// tab | :jb-h: Figura.h

```cpp
#ifndef FIGURA_H
#define FIGURA_H


class Figura {
protected:
    int brStranica;
    double *stranice;

public:
    Figura();

    Figura(int brStranica, double *stranice);

    virtual double Povrsina();

    virtual void Prikazi();

    virtual ~Figura();
};


#endif
```

///

/// tab | :jb-cpp: Figura.cpp

```cpp
#include "Figura.h"

#include <iostream>

Figura::Figura() {
    brStranica = 0;
    stranice = nullptr;
}

Figura::Figura(int brStranica, double *stranice) {
    this->brStranica = brStranica;
    this->stranice = stranice;
}

double Figura::Povrsina() {
    return 0;
}

void Figura::Prikazi() {
    std::cout << "[" << brStranica << "]: ";
    for (int i = 0; i < brStranica; i++) {
        std::cout << stranice[i] << " ";
    }
    std::cout << std::endl;
}

Figura::~Figura() {
    delete[] stranice;
}
```

///

/// tab | :jb-h: Kvadrat.h

```cpp
#ifndef KVADRAT_H
#define KVADRAT_H
#include "Figura.h"


class Kvadrat : public Figura {
public:
    Kvadrat();

    Kvadrat(double a);

    double Povrsina() override;

    void Prikazi() override;

    ~Kvadrat() override;
};


#endif
```

///

/// tab | :jb-cpp: Kvadrat.cpp

```cpp
#include "Kvadrat.h"

#include <iostream>

Kvadrat::Kvadrat() : Figura(4, new double[4]) {

}

Kvadrat::Kvadrat(double a) : Figura(4, new double[4]) {
    stranice[0] = stranice[1] = stranice[2] = stranice[3] = a;
}

double Kvadrat::Povrsina() {
    return stranice[0] * stranice[0];
}

void Kvadrat::Prikazi() {
    std::cout << "Kvadrat: a = " << stranice[0] << std::endl;
}

Kvadrat::~Kvadrat() {
    delete[] stranice;
}
```

///

/// tab | :jb-h: Pravougaonik.h

```cpp
#ifndef PRAVOUGAONIK_H
#define PRAVOUGAONIK_H
#include "Figura.h"


class Pravougaonik : public Figura {
public:
    Pravougaonik();

    Pravougaonik(double a, double b);

    double Povrsina() override;

    void Prikazi() override;

    ~Pravougaonik() override;
};


#endif
```

///

/// tab | :jb-cpp: Pravougaonik.cpp

```cpp
#include "Pravougaonik.h"

#include <iostream>

Pravougaonik::Pravougaonik() : Figura(4, new double[4]) {

}

Pravougaonik::Pravougaonik(double a, double b) : Figura(4, new double[4]) {
    stranice[0] = stranice[2] = a;
    stranice[1] = stranice[3] = b;
}

double Pravougaonik::Povrsina() {
    return stranice[0] * stranice[1];
}

void Pravougaonik::Prikazi() {
    std::cout << "Pravougaonik: a = " << stranice[0] << ", b = " << stranice[1] << std::endl;
}

Pravougaonik::~Pravougaonik() {
    delete[] stranice;
}
```

///

## Задатак 2.

На програмском језику _C++_ имплементовати класу _Point_. Класа садржи два заштићена атрибута: координате _x_ и _y_ (представљене реалним бројевима) и следеће јавне чланице:

-   подразумевани конструктор који иницијализује вредност координата на 0,
-   конструктор којим се постављају вредност _x_ и _y_ координата,
-   методу за одређивање растојања између две тачке,
-   виртуалу методу _printData_ за штампање атрибута класе,
-   виртуални деструктор.

Из класе _Point_ јавно извести класу _PointCity_ која означава локацију града на географској карти. Ова класа саджи приватне атрибуте: назив града (знаковни низ запамћен у динамичкој зони меморије), назив државе којој припада (знаковни низ запамћен у динамичкој зони меморије) и број становника, као и следеће јавне чланице:

-   подразумевани конструктор,
-   конструктор којим се постављају вредности свих атрибута,
-   предефинисану методу _printData_ која штампа податке о класи (додати назив и број становника),
-   деструктор који брише податке из динамичке зоне меморије уколико постоје.

У функцији _main_ инстанцирати низ објеката класе _PointCity_ на основу података из унапред спремљене датотеке (_LV3Zad3.txt_). Подаци су уписани у формату назив града, па назив државе којој припада па број становника. Подаци су међусобно одвојени табулатом, а називи градова и држава могу да имају бланко знак у себи, па је потребно да се и томе води рачуна.

/// example | Пример тест података
Belgrade&emsp;&emsp;Serbia 1,166,763[210]

Los Angeles&nbsp;&nbsp;United States 3,884,307[103]
///

Обратити пажњу да број становника није приказан као стандардни цео број, већ има и симболе груписања цифара које би требало да се избаце. Такође, након броја становника (у већини случајева) стоји и референца на извор које треба да се уклоне пре конвертовања текстуалне у бројну вредност. У датом примеру `1,166,763[210]` треба да се евалуира као `1166763`.

Листу градова сортирати по броју становника и сортирану листу уписати у датотеку на исти начин као што је листа из почетне датотеке (подаци о једном граду смештени у оквиру једног реда, најпре назив града, па државе и на крају број становника).

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <iostream>
#include <fstream>
#include <random>
#include <sstream>

#include "PointCity.h"

int main() {
    std::ifstream file("LV3Zad3.txt");

    if (!file.is_open()) {
        std::cout << "File not found!" << std::endl;
        return 1;
    }

    int count = 0;
    std::string line;


    while (std::getline(file, line)) {
        if (!line.empty())
            count++;
    }

    file.clear();
    file.seekg(0, std::ios::beg);

    auto cities = new PointCity*[count];

    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<int> dist(-100, 100);

    int i = 0;
    while (std::getline(file, line)) {
        if (line.empty()) {
            continue;
        }

        std::istringstream iss(line);
        std::string country, city, population;

        std::getline(iss, city, '\t');
        std::getline(iss, country, '\t');
        std::getline(iss, population, '\t');

        int popNum = 0;

        for (int j = 0; j < population.length(); j++) {
            if (population[j] == '[') {
                break;
            }

            if (std::isdigit(population[j])) {
                popNum *= 10;
                popNum += population[j] - '0';
                std::cout << population[j];
            }
        }

        cities[i++] = new PointCity(city.data(), country.data(), popNum, dist(mt), dist(mt));
    }

	file.close();

    for (int j = 0; j < count - 1; j++) {
        for (int k = j + 1; k < count; k++) {
            if (cities[j]->Population() < cities[k]->Population()) {
                auto temp = cities[j];
                cities[j] = cities[k];
                cities[k] = temp;
            }
        }
    }

    std::ofstream outFile("LV3Zad3Out.txt");

    for (int j = 0; j < count; j++) {
        outFile << *cities[j];
    }

	out.close();

    delete[] cities;

    return 0;
}
```

///

/// tab | :jb-h: Point.h

```cpp
#ifndef POINT_H
#define POINT_H


class Point {
protected:
    double x;
    double y;

public:
    Point();

    Point(double x, double y);

    double Distance(Point p);

    virtual void PrintData();

    virtual ~Point();
};


#endif
```

///

/// tab | :jb-cpp: Point.cpp

```cpp
#include "Point.h"

#include <cmath>
#include <iostream>

Point::Point() {
    this->x = 0;
    this->y = 0;
}

Point::Point(double x, double y) {
    this->x = x;
    this->y = y;
}

double Point::Distance(Point p) {
    return sqrt(pow(this->x - p.x, 2) + pow(this->y - p.y, 2));
}

void Point::PrintData() {
    std::cout << "(" << x << ", " << y << ") ";
}

Point::~Point() = default;
```

///

/// tab | :jb-h: PointCity.h

```cpp
#ifndef POINTCITY_H
#define POINTCITY_H
#include <iosfwd>
#include <bits/char_traits.h>

#include "Point.h"


class PointCity : public Point {
private:
    char *cityName;
    char *countryName;
    int population;

public:
    PointCity();

    PointCity(char *cityName, char *countryName, int population, double x, double y);

    void PrintData() override;

    int Population();

    friend std::ostream &operator<<(std::ostream &os, const PointCity &pc);

    ~PointCity() override;
};


#endif
```

///

/// tab | :jb-cpp: PointCity.cpp

```cpp
#include "PointCity.h"

#include <cstring>
#include <iostream>

PointCity::PointCity() {
    this->cityName = nullptr;
    this->countryName = nullptr;
    this->population = 0;
}

PointCity::PointCity(char *cityName, char *countryName, int population, double x, double y) : Point(x, y) {
    this->cityName = new char[strlen(cityName) + 1];
    this->countryName = new char[strlen(countryName) + 1];
    strcpy(this->cityName, cityName);
    strcpy(this->countryName, countryName);
    this->population = population;
}

void PointCity::PrintData() {
    std::cout << "(" << x << ", " << y << ")\t" << cityName << "\t" << countryName << "\t" << population << "\t" << std::endl;
}

int PointCity::Population() {
    return population;
}

std::ostream &operator<<(std::ostream &os, const PointCity &pc) {
    os << pc.cityName << "\t" << pc.countryName << "\t" << pc.population << std::endl;
    return os;
}

PointCity::~PointCity() {
    delete[] this->cityName;
    delete[] this->countryName;
}
```

///

## Задатак 3.

На програмском језику _C++_ направити класу _Buffer_ која као приватне чланове садржи:

-   капацитет бафера,
-   број уписаних елемената у бафер,
-   динамички низ елемената типа `int` који представља сам бафер.

Класа садржи и јавне чанове:

-   конструктор који иницијализује капацитет бафера,
-   деструктор,
-   виртуелну методу _push_ за додавање новог елемента на крају бафера,
-   виртуелну методу _pop_ за избацивање елемента са почетка бафера,
-   виртуелну методу _Clear_ која избацује све елементе из бафера.

Из класе _Buffer_ извести класе _QueueBuffer_ и _OrderedBuffer_.

Функционалност за _QueueBuffer_ треба да буду следеће:

-   метода _push_ треба да дода елемент на прво слободно место у бафер,
-   метода _Clear_ функционише исто као и из основне класе,
-   метода _pop_ треба да избацује претпоследњи елемент из бафера. Ако бафер има само један елемент, онда треба да избаци њега.

Функционалност за _OrderedBuffer_ треба да буду следеће:

-   метода _Clear_ треба да вредност свих елемената постави на 0,
-   метода _push_ треба да дода нови елемент у бафер тако да садржај бафера остане сортиран у растућем редоследу,
-   метода _pop_ треба да избаци елемент из средине бафера.

У функцији _main_ декларисати три показивача на класу _Buffer_, а затим динамички направити објекте класе _Buffer_, _QueueBuffer_ и _OrderedBuffer_ и испробати све методе чланице, тако што кроз 2018 пута се понови следећа секвенца за сваки од објеката:

-   три пута позвати _push_ са случајно генерисаним целим бројем,
-   два пута позвати _pop_,
-   у сваком педесетом циклусу позвати _Clear_,
-   након сваког стотог циклуса штампати садржај бафера.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <iostream>
#include <random>

#include "Buffer.h"
#include "QueueBuffer.h"
#include "OrderedBuffer.h"

int main() {
    Buffer *buf1, *buf2, *buf3;

    buf1 = new Buffer(10);
    buf2 = new QueueBuffer(10);
    buf3 = new OrderedBuffer(10);

    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<int> dist(-100, 100);

    for (int i = 1; i <= 2018; i++) {
        for (int j = 0; j < 3; j++) {
            buf1->Push(dist(mt));
            buf2->Push(dist(mt));
            buf3->Push(dist(mt));
        }

        for (int j = 0; j < 2; j++) {
            buf1->Pop();
            buf2->Pop();
            buf3->Pop();
        }

        if (i % 50 == 0) {
            buf1->Clear();
            buf2->Clear();
            buf3->Clear();
        }

        if (i % 100 == 0) {
            buf1->Print();
            buf2->Print();
            buf3->Print();
            std::cout << std::endl;
        }
    }

    delete buf1;
    delete buf2;
    delete buf3;

    return 0;
}
```

///

/// tab | :jb-h: Buffer.h

```cpp
#ifndef BUFFER_H
#define BUFFER_H


class Buffer {
protected:
    int size;
    int count;
    int *data;

public:
    Buffer(int size);

    ~Buffer();

    virtual bool Push(int value);

    virtual int Pop();

    virtual void Clear();

    void Print();
};


#endif
```

///

/// tab | :jb-cpp: Buffer.cpp

```cpp
#include "Buffer.h"

#include <iostream>

Buffer::Buffer(int size) {
    this->size = size;
    this->count = 0;
    this->data = new int[size];
}

Buffer::~Buffer() {
    delete[] this->data;
}

bool Buffer::Push(int value) {
    if (this->count == this->size) {
        return false;
    }

    this->data[this->count++] = value;

    return true;
}

int Buffer::Pop() {
    if (this->count == 0) {
        return 0;
    }

    int value = this->data[0];
    this->count--;

    for (int i = 0; i < this->count; i++) {
        this->data[i] = this->data[i + 1];
    }

    return value;
}

void Buffer::Clear() {
    this->count = 0;
}

void Buffer::Print() {
    for (int i = 0; i < this->count; i++) {
        std::cout << this->data[i] << " ";
    }

    std::cout << std::endl;
}
```

///

/// tab | :jb-h: QueueBuffer.h

```cpp
#ifndef QUEUEBUFFER_H
#define QUEUEBUFFER_H
#include "Buffer.h"


class QueueBuffer : public Buffer {
public:
    QueueBuffer(int size);

    bool Push(int value) override;

    int Pop() override;

    void Clear() override;
};


#endif
```

///

/// tab | :jb-cpp: QueueBuffer.cpp

```cpp
#include "QueueBuffer.h"

QueueBuffer::QueueBuffer(int size) : Buffer(size) {}

bool QueueBuffer::Push(int value) {
    if (this->count == this->size) {
        return false;
    }

    this->data[this->count++] = value;

    return true;
}

int QueueBuffer::Pop() {
    if (this->count == 0) {
        return 0;
    }

    if (this->count == 1) {
        return this->data[--this->count];
    }

    int value = this->data[this->count - 2];
    this->data[this->count - 2] = this->data[this->count - 1];
    this->count--;

    return value;
}

void QueueBuffer::Clear() {
    this->count = 0;
}
```

///

/// tab | :jb-h: OrderedBuffer.h

```cpp
#ifndef ORDEREDBUFFER_H
#define ORDEREDBUFFER_H
#include "Buffer.h"


class OrderedBuffer : public Buffer {
public:
    OrderedBuffer(int size);

    bool Push(int value) override;

    int Pop() override;

    void Clear() override;
};


#endif
```

///

/// tab | :jb-cpp: OrderedBuffer.cpp

```cpp
#include "OrderedBuffer.h"

OrderedBuffer::OrderedBuffer(int size) : Buffer(size) {}

bool OrderedBuffer::Push(int value) {
    if (this->count == this->size) {
        return false;
    }

    int i = 0;
    while (i < this->count && this->data[i] < value) {
        i++;
    }

    for (int j = this->count; j > i; j--) {
        this->data[j] = this->data[j - 1];
    }

    this->data[i] = value;
    this->count++;

    return true;
}

int OrderedBuffer::Pop() {
    if (this->count == 0) {
        return 0;
    }

    int value = this->data[this->count / 2];
    for (int i = this->count / 2; i < this->count - 1; i++) {
        this->data[i] = this->data[i + 1];
    }

    this->count--;

    return value;
}

void OrderedBuffer::Clear() {
    for (int i = 0; i < this->count; i++) {
        this->data[i] = 0;
    }

    this->count = 0;
}
```

///

## Задатак 4.

На програмском језику _C++_ направити класу _Command_ која представља апстракцију команди и која као чланове има:

-   _title_ - назив команде,
-   _value_ - вредност параметра (`#!cpp char*`),
-   конструктор који поставља параметре _title_ и _value_,
-   виртуалну методу _execute_ (извршење команде) која исписује назив команде (_title_).

Из класе _Command_ извести три класе: _Draw_, _Save_ и _Print_. Свака класа дефинише _title_ („_Draw_”, „_Save_”, „_Print_”) и предефинише _execute_ методу (исписује параметре _title_ и _value_ извршене операције).

Направити класу _CommandHistory_ која памти команде и има реализован _undo_ механизам тако што класа садржи следеће чланове:

-   вектор показивача на објекте класе _Command_ величине 2019,
-   тренутни број запамћених команди,
-   методу _undo()_ која брише задњи елемент листе,
-   методу _create(int x)_ која на основу параметра _x_ прави одговарајућу команду (објекат класе _Draw_, _Save_, _Print_ - уколико у вектору команди нема више места брише се прва уписана команда и додаје нова),
-   методу _execute()_ која позива методу _execute()_ задње издате команде.

У функцији _main_ инстанцирати објекат класе _CommandHistory_ и испробати све методе свих направљених класа. Напунити _CommandHistory_ са по 673 _Draw_, _Save_ и _Print_ команди, извршити их и испразнити бафер.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include "CommandHistory.h"
#include "Draw.h"
#include "Save.h"
#include "Print.h"

int main() {
    auto cmd0 = new Command(new char[]{"Test command"}, new char[]{"This is a test"});
    auto cmd1 = new Draw(new char[]{"Command to Draw"});
    auto cmd2 = new Save(new char[]{"Command to Save"});
    auto cmd3 = new Print(new char[]{"Command to Print"});

    cmd0->Execute();
    cmd1->Execute();
    cmd2->Execute();
    cmd3->Execute();

    delete cmd0;
    delete cmd1;
    delete cmd2;
    delete cmd3;

    auto history = new CommandHistory();

    for (int j = 0; j < 673; j++) {
        history->Create(j % 3);
    }

    for (int i = 0; i < 2019; i++) {
        history->Execute();
        history->Undo();
    }

    delete history;

    return 0;
}
```

///

/// tab | :jb-h: Command.h

```cpp
#ifndef COMMAND_H
#define COMMAND_H


class Command {
protected:
    char *title;
    char *value;

public:
    Command(char *title, char *value);

    virtual void Execute();
};


#endif
```

///

/// tab | :jb-cpp: Command.cpp

```cpp
#include "Command.h"

#include <cstring>
#include <iostream>

Command::Command(char* title, char* value) {
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);
    this->value = new char[strlen(value) + 1];
    strcpy(this->value, value);
}

void Command::Execute() {
    std::cout << this->title << std::endl;
}
```

///

/// tab | :jb-h: Draw.h

```cpp
#ifndef DRAW_H
#define DRAW_H
#include "Command.h"


class Draw : public Command {
public:
    Draw(char *value);

    void Execute() override;
};


#endif
```

///

/// tab | :jb-cpp: Draw.cpp

```cpp
#include "Draw.h"

#include <iostream>

Draw::Draw(char *value) : Command(new char[]{"Draw"}, value) {}

void Draw::Execute() {
    std::cout << this->title << ": " << this->value << std::endl;
}
```

///

/// tab | :jb-h: Save.h

```cpp
#ifndef SAVE_H
#define SAVE_H
#include "Command.h"


class Save : public Command {
public:
    Save(char *value);

    void Execute() override;
};


#endif
```

///

/// tab | :jb-cpp: Save.cpp

```cpp
#include "Save.h"

#include <iostream>

Save::Save(char *value) : Command(new char[]{"Save"}, value) {}

void Save::Execute() {
    std::cout << this->title << ": " << this->value << std::endl;
}
```

///

/// tab | :jb-h: Print.h

```cpp
#ifndef PRINT_H
#define PRINT_H
#include "Command.h"


class Print : public Command {
public:
    Print(char *value);

    void Execute() override;
};


#endif
```

///

/// tab | :jb-cpp: Print.cpp

```cpp
#include "Print.h"

#include <iostream>

Print::Print(char *value) : Command(new char[]{"Print"}, value) {}

void Print::Execute() {
    std::cout << this->title << ": " << this->value << std::endl;
}
```

///

/// tab | :jb-h: CommandHistory.h

```cpp
#ifndef COMMANDHISTORY_H
#define COMMANDHISTORY_H
#include "Command.h"


class CommandHistory {
private:
    Command **commands = new Command*[2019];
    int count= 0;

public:
    bool Undo();

    bool Create(int x);

    bool Execute();

    ~CommandHistory();
};


#endif
```

///

/// tab | :jb-cpp: CommandHistory.cpp

```cpp
#include "CommandHistory.h"

#include <cstdlib>

#include "Command.h"
#include "Draw.h"
#include "Save.h"
#include "Print.h"

enum COMMAND {
    DRAW,
    SAVE,
    PRINT,
};

char *randStr(int len) {
    char *str = new char[len + 1];
    for (int i = 0; i < len; i++) {
        str[i] = rand() % 26 + 97;
    }
    str[len] = '\0';
    return str;

}

bool CommandHistory::Create(int x) {
    Command *cmd;
    char *val = randStr(10);

    switch (x) {
        case DRAW:
            cmd = new Draw(val);
            break;
        case SAVE:
            cmd = new Save(val);
            break;
        case PRINT:
            cmd = new Print(val);
            break;
        default:
            return false;
    }

    delete val;

    commands[count++] = cmd;

    return true;
}

bool CommandHistory::Undo() {
    if (count == 0) {
        return false;
    }

    delete commands[count - 1];
    commands[count - 1] = nullptr;

    count--;

    return true;
}

bool CommandHistory::Execute() {
    if (count == 0) {
        return false;
    }

    commands[count - 1]->Execute();

    return true;
}

CommandHistory::~CommandHistory() {
    delete[] commands;
}
```

///

## Задатак 5.

На програмском језику _C++_ дефинисати:

-   класу _Broj_ која садржи:
    -   атрибут _vrsta_ (`#!cpp char*`)
    -   атрибут _vrednost_ (`#!cpp double`)
    -   јавну методу за поређење два броја (по вредности)
    -   виртуелну јавну методу _Print_ за приказ врсте и вредности броја на стандардни излаз,
    -   заштићену виртуелну методу за постављање вредности броја,
    -   виртуелну методу за враћање вредности броја.
-   класу _RacionalanBroj_ изведену из класе _Broj_ за представљање бројева облика $\frac{a}{b}$, где су $a$ и $b$ цели бројеви.
-   класу _KompleksanBroj_ изведену из класе _Broj_ за представљање бројева облика $a + j\cdot b$, а под вредношћу броја подразумева се његов модул.

У изведеним класама дефинисати приватне атрибуте којима је одређен одговарајући број и конструкторе који постављају одређене атрибуте.

У функцији _main_ инстанцирати низ од 2018 показивача на објекте типа _Broj_, од којих 1009 указују на рационалне, а 1009 на комплексне бројеве. Вредности бројева или учитати из унапред дефинисане датотеке или их случајно генерисати. Сортирати бројеве у низу по вредности у опадајућем редоследу и уписати их у текстуалниу датотеку.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <fstream>
#include <random>

#include "Broj.h"
#include "KompleksanBroj.h"
#include "RacionalanBroj.h"

int main() {
    auto brojevi = new Broj*[2018];

    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_real_distribution<double> realDist(-100, 100);
    std::uniform_int_distribution<int> intDist(-100, 100);

    int n = 0;
    for (int i = 0; i < 1009; i++) {
        brojevi[n++] = new RacionalanBroj(intDist(mt), intDist(mt));
        brojevi[n++] = new KompleksanBroj(realDist(mt), realDist(mt));
    }

    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (brojevi[i]->Poredi(brojevi[j]) < 0) {
                auto temp = brojevi[i];
                brojevi[i] = brojevi[j];
                brojevi[j] = temp;
            }
        }
    }

    std::ofstream out("brojevi.txt");

    for (int i = 0; i < n; i++) {
        out << brojevi[i]->Vrednost() << std::endl;
    }

	out.close();

    delete brojevi;

    return 0;
}
```

///

/// tab | :jb-h: Broj.h

```cpp
#ifndef BROJ_H
#define BROJ_H


class Broj {
protected:
    char *vrsta;
    double vrednost;

    virtual void PostaviVrednost(double vrednost);

public:
    Broj(char *vrsta, double vrednost);

    int Poredi(const Broj *broj) const;

    virtual void Print();

    virtual double Vrednost();

    ~Broj();
};


#endif
```

///

/// tab | :jb-cpp: Broj.cpp

```cpp
#include "Broj.h"

#include <cstring>
#include <iostream>

Broj::Broj(char* vrsta, double vrednost) {
    this->vrsta = new char[strlen(vrsta) + 1];
    strcpy(this->vrsta, vrsta);
    this->vrednost = vrednost;
}

void Broj::PostaviVrednost(double vrednost) {
    this->vrednost = vrednost;
}

int Broj::Poredi(const Broj *broj) const {
    if (this->vrednost > broj->vrednost) {
        return 1;
    }

    if (this->vrednost < broj->vrednost) {
        return -1;
    }

    return 0;
}

void Broj::Print() {
    std::cout << this->vrsta << ": " << this->vrednost << std::endl;
}

double Broj::Vrednost() {
    return this->vrednost;
}

Broj::~Broj() {
    delete[] this->vrsta;
}
```

///

/// tab | :jb-h: RacionalanBroj.h

```cpp
#ifndef RACIONALANBROJ_H
#define RACIONALANBROJ_H
#include "Broj.h"


class RacionalanBroj : public Broj {
private:
    int a;
    int b;

public:
    RacionalanBroj(int a, int b);

    void Print() override;
};


#endif
```

///

/// tab | :jb-cpp: RacionalanBroj.cpp

```cpp
#include "RacionalanBroj.h"

#include <iostream>

RacionalanBroj::RacionalanBroj(int a, int b) : Broj(new char[]{"Racionalan broj"}, static_cast<double>(a) / b) {
    this->a = a;
    this->b = b;
}

void RacionalanBroj::Print() {
    std::cout << this->vrsta << ": " << this->a << "/" << this->b << std::endl;
}
```

///

/// tab | :jb-h: KompleksanBroj.h

```cpp
#ifndef KOMPLEKSANBROJ_H
#define KOMPLEKSANBROJ_H

#include "Broj.h"


class KompleksanBroj : public Broj {
private:
    double a;
    double b;

public:
    KompleksanBroj(double a, double b);

    void Print() override;
};


#endif
```

///

/// tab | :jb-cpp: KompleksanBroj.cpp

```cpp
#include "KompleksanBroj.h"

#include <cmath>
#include <iostream>

KompleksanBroj::KompleksanBroj(double a, double b) : Broj(new char[]{"Kompleksan broj"}, std::sqrt(pow(a, 2) + pow(b, 2))) {
    this->a = a;
    this->b = b;
}

void KompleksanBroj::Print() {
    std::cout << this->vrsta << ": " << this->a;

    if (this->b != 0) {
        std::cout << (this->b < 0 ? " - " : " + ") << "j ⋅ " << std::abs(this->b);
    }

    std::cout << std::endl;
}
```

///

## Задатак 6.

На програмском језику _C++_ направити класу _Window_ која као чланове има:

-   _title_ - назив прозора,
-   _state_ - стање прозора (отворен/затворен),
-   виртуалну методу _draw()_ која исписује вредности параметара _title_ и _state_,
-   методу _open()_ - отварање прозора,
-   методу _close()_ - затварање прозора.

При отварању и затварању прозора се модификује стање прозора (_state_). Из класе _Window_ извести две класе: _DialogWindow_ и _DocumentWindow_. Класа _DialogWindow_ предефинише методу _draw_ тако што исписује на екрану „_DialogWindow nacrtan_”, и има додатне две методе:

-   _confirm()_ - затвара прозор и затим враћа вредност 1,
-   _cancel()_ - затвара прозор и затим враћа вредност 0.

Класа _DocumentWindow_ предефинише _draw_ тако што исписује на екрану „DocumentWindow nacrtan”.

У функцији _main_ дефинисати низ од 2018 показивача типа _Window_, инстанцирате по 1009 објеката класе _DialogWindow_ и _DocumentWindow_ и испробати све методе направљених класа. На крају сортирати све прозоре по називу и сортирани низ уписати у текстуалну датотеку.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <cstring>
#include <fstream>
#include <iostream>

#include "DialogWindow.h"
#include "DocumentWindow.h"
#include "Window.h"

char *randStr(int len) {
    char *str = new char[len + 1];
    for (int i = 0; i < len; i++) {
        str[i] = rand() % 26 + 97;
    }
    str[len] = '\0';
    return str;

}

int main() {
    auto windows = new Window*[2018];

    int n = 0;
    for (int i = 0; i < 1009; i++) {
        windows[n++] = new DialogWindow(randStr(10), (i + n) % 2 == 0 ? WindowState::opened : WindowState::closed);
        windows[n++] = new DocumentWindow(randStr(10), (i + n) % 6 == 0 ? WindowState::opened : WindowState::closed);
    }

    for (int i = 0; i < n; i++) {
        windows[i]->Draw();
        if (i % 2 == 0) {
            if (dynamic_cast<DialogWindow*>(windows[i]) != nullptr) {
                dynamic_cast<DialogWindow*>(windows[i])->Confirm();
            } else {
                windows[i]->Open();
            }
        }

        if (i % 6 == 0) {
            if (dynamic_cast<DialogWindow*>(windows[i]) != nullptr) {
                dynamic_cast<DialogWindow*>(windows[i])->Cancel();
            } else {
                windows[i]->Close();
            }
        }
    }

    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (strcmp(windows[i]->Title(), windows[j]->Title()) > 0) {
                Window *tmp = windows[i];
                windows[i] = windows[j];
                windows[j] = tmp;
            }
        }
    }

    std::ofstream out("windows.txt");
    for (int i = 0; i < n; i++) {
        out << windows[i]->Title() << ": " << (windows[i]->State() == WindowState::opened ? "opened" : "closed") << std::endl;
    }

	out.close();

    delete[] windows;

    return 0;
}
```

///

/// tab | :jb-h: Window.h

```cpp
#ifndef WINDOW_H
#define WINDOW_H

enum class WindowState {
    opened,
    closed,
};

class Window {
protected:
    char *title;
    WindowState state;

public:
    Window(const char *title, WindowState state);

    virtual void Draw();

    bool Open();

    bool Close();

    char *Title() const {
        return title;
    }

    WindowState State() const {
        return state;
    }

    ~Window();
};


#endif
```

///

/// tab | :jb-cpp: Window.cpp

```cpp
#include "Window.h"

#include <cstring>
#include <iostream>

Window::Window(const char *title, WindowState state) {
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);
    this->state = state;
}

void Window::Draw() {
    std::cout << title << ": " << (state == WindowState::opened ? "opened" : "closed") << std::endl;
}

bool Window::Open() {
    if (state == WindowState::closed) {
        state = WindowState::opened;
        return true;
    }

    return false;
}

bool Window::Close() {
    if (state == WindowState::opened) {
        state = WindowState::closed;
        return true;
    }

    return false;
}

Window::~Window() {
    delete[] title;
}
```

///

/// tab | :jb-h: DialogWindow.h

```cpp
#ifndef DIALOGWINDOW_H
#define DIALOGWINDOW_H
#include "Window.h"


class DialogWindow : public Window {
public:
    DialogWindow(const char *title, WindowState state);

    void Draw() override;

    int Confirm();

    int Cancel();
};


#endif
```

///

/// tab | :jb-cpp: DialogWindow.cpp

```cpp
#include "DialogWindow.h"

#include <iostream>

DialogWindow::DialogWindow(const char *title, WindowState state) : Window(title, state) {}

void DialogWindow::Draw() {
    Window::Draw();
    std::cout << "DialogWindow nacrtan" << std::endl;
}

int DialogWindow::Confirm() {
    Close();
    return 1;
}

int DialogWindow::Cancel() {
    Close();
    return 0;
}
```

///

/// tab | :jb-h: DocumentWindow.h

```cpp
#ifndef DOCUMENTWINDOW_H
#define DOCUMENTWINDOW_H
#include "Window.h"


class DocumentWindow : public Window {
public:
    DocumentWindow(const char *title, WindowState state);

    void Draw() override;
};


#endif
```

///

/// tab | :jb-cpp: DocumentWindow.cpp

```cpp
#include "DocumentWindow.h"

#include <iostream>

DocumentWindow::DocumentWindow(const char *title, WindowState state) : Window(title, state) {}

void DocumentWindow::Draw() {
    Window::Draw();
    std::cout << "DocumentWindow nacrtan" << std::endl;
}
```

///

## Задатак 7.

На програмском језику _C++_ направити класу _Artikal_ која као чланове има:

-   назив,
-   цену,
-   виртуалну методу _showDescription()_ која исписује параметре назив и цена,
-   методу _getPrice()_ која враћа цену артикла.

Из класе _Artikal_ извести две класе: _Laptop_ и _Torba_. Класа _Laptop_ поседује следеће чланове:

-   opis (`#!cpp char*`),
-   stanje (укључен-искључен),
-   предефинисану методу _showDescription()_ која исписује на екрану _naziv_, _cenu_ и _opis_,
-   методу _turnOn()_ - модификује се стање и исписује се порука на екрану,
-   методу _turnOff()_ - модификује се стање и исписује порука на екрану.

Класа _Torba_ садржи следеће чланове:

-   атрибут _sadrzaj_ - типа _Artikal_, показивач на артикал тренутно смештен у торби,
-   предефинисати методу _showDescription()_ која исписује на екрану текст „_Torba za Laptop računar_” и након тога зове методу _showDescription()_ за артикал смештен у торби,
-   методу _put(Artikal &a)_ - симулација смештања артикла у торбу уколико је празна и исписује поруку да ли је артикал смештен или не,
-   методу _remove()_ - симулира вађење артикла из торбе.

У функцији _main_ инстанцирати низ од 2018 показивача типа _Artikal_ и по 1009 објеката класе _Laptop_ и _Torba_ и испробати све методе обе класе. На крају, сортирати све производе по цени и резултат сортирања уписати у текстуалну датотеку.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <fstream>
#include <iostream>
#include <random>

#include "Artikal.h"
#include "Laptop.h"
#include "Torba.h"

char *randStr(int len) {
    char *str = new char[len + 1];
    for (int i = 0; i < len; i++) {
        str[i] = rand() % 26 + 97;
    }
    str[len] = '\0';
    return str;

}

int main() {
    auto artikli = new Artikal*[2018];

    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<int> intDist(100, 20000);

    int n = 0;
    for (int i = 0; i < 1009; i++) {
        artikli[n++] = new Laptop(randStr(10), intDist(mt), randStr(30));
        artikli[n++] = new Torba(randStr(10), intDist(mt));

        if (i % 3 == 0) {
            dynamic_cast<Torba*>(artikli[n - 1])->Put(artikli[n - 2]);
        }
    }

    for (int i = 0; i < n; i++) {
        if (i % 9 == 0 && dynamic_cast<Torba*>(artikli[i]) != nullptr) {
            dynamic_cast<Torba*>(artikli[i])->ShowDescription();
            dynamic_cast<Torba*>(artikli[i])->Remove();
        }

        if (dynamic_cast<Laptop*>(artikli[i])) {
            dynamic_cast<Laptop*>(artikli[i])->ShowDescription();

            if (i % 3 == 0) {
                dynamic_cast<Laptop*>(artikli[i])->TurnOn();
            }

            if (i % 9 == 0) {
                dynamic_cast<Laptop*>(artikli[i])->TurnOff();
            }
        }
    }

    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (artikli[i]->GetPrice() > artikli[j]->GetPrice()) {
                auto pom = artikli[i];
                artikli[i] = artikli[j];
                artikli[j] = pom;
            }
        }
    }

    std::ofstream outFile("artikli.txt");

    for (int i = 0; i < n; i++) {
        outFile << artikli[i]->GetPrice() << std::endl;
    }

    outFile.close();

    delete[] artikli;

    return 0;
}
```

///

/// tab | :jb-h: Artikal.h

```cpp
#ifndef ARTIKAL_H
#define ARTIKAL_H


class Artikal {
protected:
    char *naziv;
    int cena;

public:
    Artikal(char *naziv, int cena);

    virtual void ShowDescription();

    int GetPrice();
};


#endif
```

///

/// tab | :jb-cpp: Artikal.cpp

```cpp
#include "Artikal.h"

#include <cstring>
#include <iostream>

Artikal::Artikal(char *naziv, int cena) {
    this->naziv = new char[strlen(naziv) + 1];
    strcpy(this->naziv, naziv);
    this->cena = cena;
}

void Artikal::ShowDescription() {
    std::cout << "Naziv: " << this->naziv << std::endl;
    std::cout << "Cena: " << this->cena << std::endl;
}

int Artikal::GetPrice() {
    return this->cena;
}
```

///

/// tab | :jb-h: Laptop.h

```cpp
#ifndef LAPTOP_H
#define LAPTOP_H
#include "Artikal.h"

enum class LaptopState {
    on,
    off
};

class Laptop : public Artikal {
private:
    char *opis;
    LaptopState stanje;

public:
    Laptop(char *naziv, int cena, char *opis);

    void ShowDescription() override;

    void TurnOn();

    void TurnOff();
};


#endif
```

///

/// tab | :jb-cpp: Laptop.cpp

```cpp
#include "Laptop.h"

#include <cstring>
#include <iostream>

Laptop::Laptop(char *naziv, int cena, char *opis) : Artikal(naziv, cena) {
    this->opis = new char[strlen(opis) + 1];
    strcpy(this->opis, opis);
    this->stanje = LaptopState::off;
}

void Laptop::ShowDescription() {
    std::cout << this->naziv << " " << this->cena << " " << this->opis << std::endl;
}

void Laptop::TurnOn() {
    this->stanje = LaptopState::on;
}

void Laptop::TurnOff() {
    this->stanje = LaptopState::off;
}
```

///

/// tab | :jb-h: Torba.h

```cpp
#ifndef TORBA_H
#define TORBA_H
#include "Artikal.h"


class Torba : public Artikal {
private:
    Artikal *sadrzaj;

public:
    Torba(char *naziv, int cena);

    void ShowDescription() override;

    bool Put(Artikal *artikal);

    bool Remove();
};


#endif
```

///

/// tab | :jb-cpp: Torba.cpp

```cpp
#include "Torba.h"

#include <iostream>

Torba::Torba(char* naziv, int cena) : Artikal(naziv, cena) {}

void Torba::ShowDescription() {
    std::cout << "Torba za Laptop računar. ";

    if (this->sadrzaj == nullptr) {
        std::cout << "Prazna." << std::endl;
        return;
    }

    this->sadrzaj->ShowDescription();
}

bool Torba::Put(Artikal *artikal) {
    if (this->sadrzaj != nullptr) {
        std::cout << "Torba je puna!" << std::endl;
        return false;
    }

    this->sadrzaj = artikal;
    std::cout << "Artikal je uspešno smešten u torbi." << std::endl;

    return true;
}

bool Torba::Remove() {
    if (this->sadrzaj == nullptr) {
        std::cout << "Torba je prazna!" << std::endl;
        return false;
    }

    this->sadrzaj = nullptr;
    std::cout << "Artikal je uspešno izvađen iz torbe." << std::endl;

    return true;
}
```

///

## Задатак 8.

На програмском језику _C++_ направити класу _GeometrijskaSlika_ која садржи приватне атрибуте:

-   боја (дефинисана својим компонентама: _R_-црвено, _G_-зелено и _B_-плаво чије су вредности у опсегу 0–255),
-   тежиште (одређено _x_ и _y_ координатама).

Класа садржи следеће јавне чланице:

-   конструктор који иницијализује све приватне атрибуте,
-   методу за израчунавање растојања фигуре (њеног тежишта) од координатног почетка,
-   методу за транслирање фигуре за задати померај (дефинисан својим _x_ и _y_ компонентама),
-   виртуелну методу _Show_ за приказ атрибута боја и тежиште на стандардни излаз,
-   заштићену виртуелну методу за израчунавање површине фигуре,
-   методу за испитивање да ли је фигура већа (по површини) од друге задате фигуре.

Направити и класе _Krug_ (чији је приватни атрибут полупречник) и _Kvadrat_ (чији је приватни атрибут стрница). У изведеним класама дефинисати конструкторе и методе за израчунавање површине. Предефинисати методе за приказ атрибута тако што ће пре приказа атрибута бити исписан тип фигуре, а после приказа атрибута родитељске класе приказати и атрибуте дефинисане у изведеним класама.

У функцији _main_ инстанцирати по 2018 објеката класе _Kvadrat_ и _Krug_ у динамичкој зони меморије. Поставити све њихове атрибуте на случајне вредност из опсега 0–255. Након тога транслирати их за вектор $(a, b)$. За сваку фигуру одредити посебно $a$ и $b$ као случајно изабрану вредност из интервала $(-12{,}8, 12{,}8)$.

Сортирати све инстанциране фигуре по површини у неопадајућем редоследу и у текстуалну датотеку уписати све њихове атрибуте, површину и растојање од координатног почетка. Водити рачуна да се подаци о једној фигури уписују у један ред излазне датотеке.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <iostream>
#include <random>

#include "GeometrijskaSlika.h"
#include "Krug.h"
#include "Kvadrat.h"

int main() {
    auto figure = new GeometrijskaSlika*[2018];

    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<short> shortDist(0, 255);
    std::uniform_real_distribution<double> doubleDist1(-100, 100);
    std::uniform_real_distribution<double> doubleDist2(-12.8, 12.8);

    int n = 0;
    for (int i = 0; i < 1009; i++) {
        figure[n++] = new Krug(shortDist(mt), shortDist(mt), shortDist(mt), doubleDist1(mt), doubleDist1(mt), doubleDist1(mt));
        figure[n++] = new Kvadrat(shortDist(mt), shortDist(mt), shortDist(mt), doubleDist1(mt), doubleDist1(mt), doubleDist1(mt));
    }

    for (int i = 0; i < n; i++) {
        figure[i]->Transliraj(doubleDist2(mt), doubleDist2(mt));
    }

    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (figure[i]->Uporedi(figure[j]) > 0) {
                auto pom = figure[i];
                figure[i] = figure[j];
                figure[j] = pom;
            }
        }
    }

    std::ofstream out("figure.txt");

    for (int i = 0; i < n; i++) {
        out << figure[i];
    }

    delete[] figure;

    return 0;
}
```

///

/// tab | :jb-h: GeometrijskaSlika.h

```cpp
#ifndef GEOMETRIJSKASLIKA_H
#define GEOMETRIJSKASLIKA_H
#include <fstream>

struct Boja {
    short r, g, b;
};

struct Vek2 {
    double x, y;
};

class GeometrijskaSlika {
private:
    Boja boja{};
    Vek2 teziste{};

protected:
    virtual double Povrsina();

public:
    GeometrijskaSlika(Boja boja, Vek2 teziste);

    GeometrijskaSlika(short r, short g, short b, double x, double y);

    double Rastojanje();

    void Transliraj(Vek2 pomeraj);

    void Transliraj(double x, double y);

    virtual void Show();

    int Uporedi(GeometrijskaSlika *figura);

    friend std::ostream &operator<<(std::ostream& out, GeometrijskaSlika* figura);
};


#endif
```

///

/// tab | :jb-cpp: GeometrijskaSlika.cpp

```cpp
#include "GeometrijskaSlika.h"

#include <cmath>
#include <iostream>

GeometrijskaSlika::GeometrijskaSlika(Boja boja, Vek2 teziste) {
    this->boja = boja;
    this->teziste = teziste;
}

GeometrijskaSlika::GeometrijskaSlika(short r, short g, short b, double x, double y) {
    this->boja = {r, g, b};
    this->teziste = {x, y};
}

double GeometrijskaSlika::Rastojanje() {
    return sqrt(pow(teziste.x, 2) + pow(teziste.y, 2));
}

void GeometrijskaSlika::Transliraj(Vek2 pomeraj) {
    teziste.x += pomeraj.x;
    teziste.y += pomeraj.y;
}

void GeometrijskaSlika::Transliraj(double x, double y) {
    teziste.x += x;
    teziste.y += y;
}

void GeometrijskaSlika::Show() {
    std::cout << "(" << boja.r << ", " << boja.g << ", " << boja.b << "); (" << teziste.x << ", " << teziste.y << ")";
}

int GeometrijskaSlika::Uporedi(GeometrijskaSlika *figura) {
    if (this->Povrsina() > figura->Povrsina()) {
        return 1;
    }

    if (this->Povrsina() < figura->Povrsina()) {
        return -1;
    }

    return 0;
}

double GeometrijskaSlika::Povrsina() {
    return 0;
}

std::ostream &operator<<(std::ostream& out, GeometrijskaSlika* figura) {
    out << "(" << figura->boja.r << ", " << figura->boja.g << ", " << figura->boja.b << "); (" << figura->teziste.x << ", " << figura->teziste.y << "); " << figura->Povrsina()<< "; " << figura->Rastojanje() << std::endl;
    return out;
}
```

///

/// tab | :jb-h: Krug.h

```cpp
#ifndef KRUG_H
#define KRUG_H
#include "GeometrijskaSlika.h"


class Krug : public GeometrijskaSlika {
private:
    double poluprecnik;

public:
    Krug(Boja boja, Vek2 teziste, double poluprecnik);

    Krug(short r, short g, short b, double x, double y, double poluprecnik);

    double Povrsina() override;

    void Show() override;
};


#endif
```

///

/// tab | :jb-cpp: Krug.cpp

```cpp
#include "Krug.h"

#include <cmath>
#include <iostream>

Krug::Krug(Boja boja, Vek2 teziste, double poluprecnik) : GeometrijskaSlika(boja, teziste) {
    this->poluprecnik = poluprecnik;
}

Krug::Krug(short r, short g, short b, double x, double y, double poluprecnik) : GeometrijskaSlika(r, g, b, x, y) {
    this->poluprecnik = poluprecnik;
}

double Krug::Povrsina() {
    return std::pow(poluprecnik, 2) * M_PI;
}

void Krug::Show() {
    std::cout << "Krug: ";
    GeometrijskaSlika::Show();
    std::cout << "; r =" << poluprecnik << std::endl;
}
```

///

/// tab | :jb-h: Kvadrat.h

```cpp
#ifndef KVADRAT_H
#define KVADRAT_H
#include "GeometrijskaSlika.h"


class Kvadrat : public GeometrijskaSlika {
private:
    double stranica;

public:
    Kvadrat(Boja boja, Vek2 teziste, double stranica);

    Kvadrat(short r, short g, short b, double x, double y, double stranica);

    double Povrsina() override;

    void Show() override;
};


#endif
```

///

/// tab | :jb-cpp: Kvadrat.cpp

```cpp
#include "Kvadrat.h"

#include <cmath>
#include <iostream>

Kvadrat::Kvadrat(Boja boja, Vek2 teziste, double stranica) : GeometrijskaSlika(boja, teziste) {
    this->stranica = stranica;
}

Kvadrat::Kvadrat(short r, short g, short b, double x, double y, double stranica) : GeometrijskaSlika(r, g, b, x, y) {
    this->stranica = stranica;
}

double Kvadrat::Povrsina() {
    return std::pow(stranica, 2);
}

void Kvadrat::Show() {
    std::cout << "Kvadrat: ";
    GeometrijskaSlika::Show();
    std::cout << "; a =" << stranica << std::endl;
}
```

///

## Задатак 9.

На програмском језику _C++_ направити:

-   Класу _Displej_ која садржи:
    -   заштићени податак _cifra_ која представља хексадекадну цифру тренутно приказану на дисплеју,
    -   виртуелну методу _set_ која поставља вредност цифре. Ова метода треба да обезбеди да се невалидне вредности не прихвате,
    -   методу _reset_ која поставља цифуру на 0,
    -   виртуелну методу _increment_ која повећава садржај дисплеја за 1 по модулу 16,
    -   виртуелну методу _show_ која уписује садржај дисплеја на стандардни излаз.
-   Класу _DekadniMatricniDisplej_ јавно изведену из класе _Displej_ која садржи:
    -   приватни податак - матрицу пиксела реда *m*×*n* у којој су нулама и јединицама представљене угашене и упаљене тачке на дисплеју које формирају цифру,
    -   методу која ће унапред дефинисане садржајe матрице у складу са цифром која је тренутно приказана на дисплеју, учитати из датотеке,
    -   предефинисати меотду _set_, да прихвата само декадне цифре,
    -   предифинисати методу _increment_ тако да садржај дисплеја повећава за 1 по модулу 10,
    -   метода _show_ треба да најпре позове на извршење методу _show_ из основне класе, а затим испише садржај матрице пиксела на стандардни излаз.

У функцији _main_ инстанцирати по један објекат класа _Displej_ и _DekadniMatricniDisplej_. За оба објекта извршити следећу секвенцу акција:

-   поставити иницијалну вредност на 9,
-   извршити _k_ инкрементирања (_k_ мора бити веће од 50000),
-   позвати методу _reset_,
-   извршити _k_ инкрементирања (_k_ мора бити веће од 50000),

Након последњег, као и након сваког 2018-ог инкрементирања, позвати методу _show_ за сваки од објеката.

### Програмски ко̑д

/// tab | :jb-cpp: main.cpp

```cpp
#include <iostream>

#include "DekadniMatricniDisplej.h"
#include "Displej.h"

#define M 7
#define N 5

void Simulation(Displej *d1, DekadniMatricniDisplej *d2) {
    for (int k = 0; k < 100000; k++) {
        d1->Increment();
        d2->Increment();

        if (k % 2018 == 0) {
            d1->Show();
            d2->Show();
        }
    }
}

int main() {
    auto d1 = new Displej();
    auto d2 = new DekadniMatricniDisplej(M, N);

    d1->Set(9);
    d2->Set(9);

    Simulation(d1, d2);

    d1->Reset();
    d2->Reset();

    Simulation(d1, d2);

    delete d1;
    delete d2;

    return 0;
}
```

///

/// tab | :jb-h: Displej.h

```cpp
#ifndef DISPLEJ_H
#define DISPLEJ_H


class Displej {
protected:
    short cifra;

public:
    virtual bool Set(short val);

    void Reset();

    virtual void Increment();

    virtual void Show();
};


#endif
```

///

/// tab | :jb-cpp: Displej.cpp

```cpp
#include "Displej.h"

#include <iostream>

bool Displej::Set(short val) {
    if (val < 0 || val > 15) {
        return false;
    }

    cifra = val;
    return true;
}

void Displej::Reset() {
    cifra = 0;
}

void Displej::Increment() {
    cifra = (cifra + 1) % 16;
}

void Displej::Show() {
    std::cout << cifra << std::endl;
}
```

///

/// tab | :jb-h: DekadniMatricniDisplej.h

```cpp
#ifndef DEKADNIMATRICNIDISPLEJ_H
#define DEKADNIMATRICNIDISPLEJ_H
#include "Displej.h"


class DekadniMatricniDisplej : public Displej {
private:
    bool **pikseli;
    int m, n;

    void UcitajPiksele();

public:
    DekadniMatricniDisplej(int m, int n);

    bool Set(short val) override;

    void Increment() override;

    void Show() override;

    ~DekadniMatricniDisplej();
};


#endif
```

///

/// tab | :jb-cpp: DekadniMatricniDisplej.cpp

```cpp
#include "DekadniMatricniDisplej.h"

#include <fstream>
#include <iostream>
#include <string>

DekadniMatricniDisplej::DekadniMatricniDisplej(int m, int n) {
    this->m = m;
    this->n = n;
    pikseli = new bool *[m];
}

void DekadniMatricniDisplej::UcitajPiksele() {
    std::ifstream f("pikseli/" + std::to_string(cifra) + ".txt");

    for (int i = 0; i < m; i++) {
        pikseli[i] = new bool[n];

        for (int j = 0; j < n; j++) {
            int pixel;
            f >> pixel;
            pikseli[i][j] = pixel == 1;
        }
    }
}


bool DekadniMatricniDisplej::Set(short val) {
    if (val < 0 || val > 9) {
        return false;
    }

    cifra = val;
    return true;
}

void DekadniMatricniDisplej::Increment() {
    cifra = (cifra + 1) % 10;
}

void DekadniMatricniDisplej::Show() {
    Displej::Show();

    UcitajPiksele();

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << (pikseli[i][j] ? '*' : ' ');
        }
        std::cout << std::endl;
    }

    std::cout << std::endl;
}

DekadniMatricniDisplej::~DekadniMatricniDisplej() {
    for (int i = 0; i < m; i++) {
        delete[] pikseli[i];
    }

    delete[] pikseli;
}
```

///

/// example | Тест подаци

//// tab | :jb-txt: pikseli/0.txt

```
0 1 1 1 0
1 0 0 0 1
1 0 0 1 1
1 0 1 0 1
1 1 0 0 1
1 0 0 0 1
0 1 1 1 0
```

////

//// tab | :jb-txt: pikseli/1.txt

```
0 0 1 0 0
0 1 1 0 0
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
1 1 1 1 1
```

////

//// tab | :jb-txt: pikseli/2.txt

```
0 1 1 1 0
1 0 0 0 1
0 0 0 0 1
0 0 0 1 0
0 0 1 0 0
0 1 0 0 0
1 1 1 1 1
```

////

//// tab | :jb-txt: pikseli/3.txt

```
0 1 1 1 0
1 0 0 0 1
0 0 0 0 1
0 0 1 1 0
0 0 0 0 1
1 0 0 0 1
0 1 1 1 0
```

////

//// tab | :jb-txt: pikseli/4.txt

```
0 0 0 1 0
0 0 1 1 0
0 1 0 1 0
1 0 0 1 0
1 1 1 1 1
0 0 0 1 0
0 0 0 1 0
```

////

//// tab | :jb-txt: pikseli/5.txt

```
1 1 1 1 1
1 0 0 0 0
1 1 1 1 0
0 0 0 0 1
0 0 0 0 1
1 0 0 0 1
0 1 1 1 0
```

////

//// tab | :jb-txt: pikseli/6.txt

```
0 1 1 1 0
1 0 0 0 1
1 0 0 0 0
1 1 1 1 0
1 0 0 0 1
1 0 0 0 1
0 1 1 1 0
```

////

//// tab | :jb-txt: pikseli/7.txt

```
1 1 1 1 1
0 0 0 0 1
0 0 0 1 0
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
```

////

//// tab | :jb-txt: pikseli/8.txt

```
0 1 1 1 0
1 0 0 0 1
1 0 0 0 1
0 1 1 1 0
1 0 0 0 1
1 0 0 0 1
0 1 1 1 0
```

////

//// tab | :jb-txt: pikseli/9.txt

```
0 1 1 1 0
1 0 0 0 1
1 0 0 0 1
0 1 1 1 1
0 0 0 0 1
1 0 0 0 1
0 1 1 1 0
```

////

///
